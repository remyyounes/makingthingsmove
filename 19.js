webpackJsonp([19],{

/***/ "./src/sections/collision-perf.md":
/***/ (function(module, exports) {

module.exports = "```code\n<P5Wrapper sketch={p => {\n  // parameters\n  const dimensions = { width: 600, height: 600 }\n  const size = { width: 40, height: 40 }\n  const dragCoefficient = 0.1\n  const particles = []\n  const count = 600\n  let quadrants\n  let particle\n\n  p.setup = function() {\n    p.disableFriendlyErrors = true\n    // setup canvas\n    p.createCanvas(dimensions.width, dimensions.height, p.P2D)\n\n    // setup quadrants\n    const width = dimensions.width / 2\n    const height = dimensions.height / 2\n    const q = { x: 0, y: 0, width: dimensions.width, height: dimensions.height }\n    const q1 = { x: width, y: 0, width, height }\n    const q2 = { x: width, y: height, width, height }\n    const q3 = { x: 0, y: height, width, height }\n    const q4 = { x: 0, y: 0, width, height }\n    quadrants = [q1, q2, q3, q4]\n    /* quadrants = [q] */\n\n    // setup particles\n    for (let i = 0; i < count; i++) {\n      const particle = new Particle({\n        position: p.createVector(  \n          (Math.random() * dimensions.width),\n          (Math.random() * dimensions.height)\n        ),\n        velocity: p.createVector(  \n          Math.random() * 2,\n          Math.random() * 2\n        ),\n        size,\n      })\n      particles.push(particle)\n    }\n  }\n\n\n\n  const checkBounds = (bounds, particle) => {\n    const collision = { x: 0, y: 0 }\n    const radius = particle.size.width / 2\n    const xMin = particle.position.x - radius\n    const xMax = particle.position.x + radius\n    const yMin = particle.position.y - radius\n    const yMax = particle.position.y + radius\n\n    if (xMin <= 0 || xMax >= bounds.width) {\n      collision.x = 1\n    }\n    if (yMin <= 0 || yMax >= bounds.height) {\n      collision.y = 1\n    }\n    return collision\n  }\n\n  const contains = (bounds, particle) => {\n    const collision = { x: 0, y: 0 }\n    const radius = particle.size.width / 2\n    const xMin = particle.position.x - radius\n    const xMax = particle.position.x + radius\n    const yMin = particle.position.y - radius\n    const yMax = particle.position.y + radius\n\n    const containsHorizontally = xMin >= bounds.x && xMax <= bounds.width + bounds.x\n    const containsVertically = yMin >= bounds.y && yMax <= bounds.height + bounds.y\n\n\n    return containsHorizontally && containsVertically\n  }\n\n  const resolveOverlap = (ballA, ballB) => {\n    const delta = ballB.position.copy().sub(ballA.position)\n    const distance = delta.mag()\n    var theta = Math.atan2(delta.y, delta.x);\n    var overlap = ballA.size.width / 4 + ballB.size.width / 4 - distance;\n    ballB.position.x += overlap * Math.cos(theta);\n    ballB.position.y += overlap * Math.sin(theta);\n  }\n\n  const groupByQuadrant = () => {\n    return quadrants.map( quadrant =>\n      particles.filter( particle => contains(quadrant, particle) )\n    )\n  }\n\n  // update loop / physics\n  const update = () => {\n    const groups = groupByQuadrant()\n    console.log('groups', groups)\n    groups.map(updateGroupCollisions)\n    particles.map(updateParticle)\n  }\n  const updateGroupCollisions = balls => {\n    console.log('g', balls.length)\n    const num = balls.length\n    for (let i = 0; i < num; i++) {\n      for (let j = 0; j < num; j++) {\n        if ( i !== j ) {\n          const ballA = balls[i]\n          const ballB = balls[j]\n          const delta = ballB.position.copy().sub(ballA.position)\n          if ( delta.mag() < size.width/2 ) {\n            resolveOverlap(ballA, ballB)\n            checkCollision(ballA, ballB)\n          }\n        }\n      }\n    }\n  }\n\n  const updateParticle = (particle) => {\n\n    // check collision\n    const collision = checkBounds(dimensions, particle)\n\n    // adjust velocity according to collision\n    if (collision.x) particle.velocity.x *= -1\n    if (collision.y) particle.velocity.y *= -1\n\n\n    // update particle position and velocity then reset acceleration\n    particle.update()\n  }\n\n  const checkCollision = (ballA, ballB) => {\n    const delta = ballB.position.copy().sub(ballA.position)\n    const thetaA = Math.atan2(ballA.velocity.y, ballA.velocity.x);\n    const thetaB = Math.atan2(ballB.velocity.y, ballB.velocity.x);\n    const phi = Math.atan2(ballB.position.y, ballB.position.x);\n\n    const m1 = ballA.mass;\n    const m2 = ballB.mass;\n    const v1 = ballA.velocity.mag();\n    const v2 = ballB.velocity.mag();\n\n    const dA = thetaA - phi\n    const dB = thetaB - phi\n\n    ballA.velocity.x =\n      (v1 * Math.cos(dA) * (m1-m2) + 2*m2*v2* Math.cos(dB)) /\n      (m1 + m2) * Math.cos(phi) + v1 * Math.sin(dA) * Math.cos(phi + Math.PI/2);\n    ballA.velocity.y =\n      (v1 * Math.cos(dA) * (m1-m2) + 2*m2*v2* Math.cos(dB)) /\n      (m1 + m2) * Math.sin(phi) + v1 * Math.sin(dA) * Math.sin(phi + Math.PI/2);\n    ballB.velocity.x =\n      (v2 *  Math.cos(dB) * (m2-m1) + 2*m1*v1*Math.cos(dA)) /\n      (m1 + m2) * Math.cos(phi) + v2 * Math.sin(dB) * Math.cos(phi + Math.PI/2);\n    ballB.velocity.y=\n      (v2 *  Math.cos(dB) * (m2-m1) + 2*m1*v1*Math.cos(dA)) /\n      (m1 + m2) * Math.sin(phi) + v2 * Math.sin(dB) * Math.sin(phi + Math.PI/2);\n\n}\n\n\n  // draw loop / rendering\n  p.draw = function() {\n    // render background\n    p.background(p.color('white'))\n\n    // render particle\n    /* p.push() */\n    particles.map( particle => Art.ellipse(p, particle))\n    /* p.pop() */\n    update()\n  }\n}} />\n\n```\n"

/***/ })

});
//# sourceMappingURL=19.js.map