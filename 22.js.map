{"version":3,"file":"22.js","sources":["webpack:///./src/sections/flock-separation.md"],"sourcesContent":["module.exports = \"# Wrapping\\n\\n## Example\\n\\nWrap boids across edges\\n\\n```code\\n<P5Wrapper\\n  sketch={p => {\\n    // parameters\\n    const FORCE_PRECISION = 10000\\n    const dimensions = p.createVector(800, 600)\\n    const center = dimensions.copy().div(2)\\n    let sliders, flock = []\\n    const debug = x => { debugger; return x }\\n    const flockCfg = {\\n      count: 20,\\n      maxVelocity: 1,\\n      separation: { force: 0.001, radius: 20 },\\n      alignment: { force: 0.001, radius: 40 },\\n      cohesion: { force: 0.001, radius: 80 },\\n      size: { width: 10, height: 20 },\\n    }\\n\\n    class Boid extends Particle {\\n      constructor(props) {\\n        super(props)\\n        this.rules = props.rules || {}\\n        this.velocity = props.velocity || randomVector(this.maxVelocity)\\n      }\\n\\n      get separation() {\\n        return this.rules.separation || flockCfg.separation\\n      }\\n      get alignment() {\\n        return this.rules.alignment || flockCfg.alignment\\n      }\\n      get cohesion() {\\n        return this.rules.cohesion || flockCfg.cohesion\\n      }\\n    }\\n\\n    const randomVector = magnitudeMax => p.createVector(\\n      p.random(-1, 1),\\n      p.random(-1, 1)\\n    ).mult(magnitudeMax)\\n\\n\\n    const getSetting = (key, sliders) => {\\n       const { radius, force } = sliders[key]\\n       return ({\\n         radius: radius.value(),\\n         force: force.value() / FORCE_PRECISION,\\n       })\\n    }\\n\\n    const updateSettings = (settings, sliders) => {\\n      settings.separation = getSetting('separation', sliders)\\n      settings.alignment = getSetting('alignment', sliders)\\n      settings.cohesion = getSetting('cohesion', sliders)\\n    }\\n\\n    const renderBoid = Art.boid(p)\\n    const debugBoid = Art.debugBoid(p)\\n    const debugMotion = Art.debugMotion(p)\\n\\n    const createRuleSlider = (key, config) => ({\\n      radius: debug(p.createSlider(0, config.radius * 2, config.radius)),\\n      force: p.createSlider(0, config.force * 2 * FORCE_PRECISION, config.force * FORCE_PRECISION),\\n    })\\n\\n    const initSliders = (config) => {\\n      sliders = {\\n        separation: createRuleSlider('separation', config.separation),\\n        alignment: createRuleSlider('alignment', config.alignment),\\n        cohesion: createRuleSlider('cohesion', config.cohesion),\\n      }\\n\\n      sliders.separation.radius.position(20, 20)\\n      sliders.separation.force.position(20, 50)\\n      sliders.alignment.radius.position(20, 80)\\n      sliders.alignment.force.position(20, 110)\\n      sliders.cohesion.radius.position(20, 140)\\n      sliders.cohesion.force.position(20, 170)\\n    }\\n\\n    p.setup = function() {\\n      // setup canvas\\n      p.createCanvas(dimensions.x, dimensions.y, p.P2D)\\n\\n\\n      // init boids\\n      const initBoid = () =>  new Boid({\\n        position: center.copy(),\\n      })\\n\\n      flock = R.times( initBoid, flockCfg.count )\\n\\n      // settings\\n      // create sliders\\n      initSliders(flockCfg)\\n    }\\n\\n    const wrap = dimensions => particle => {\\n      particle.position.x += particle.position.x < 0 ? dimensions.x : 0\\n      particle.position.y += particle.position.y < 0 ? dimensions.y : 0\\n      particle.position.x %= dimensions.x\\n      particle.position.y %= dimensions.y\\n    }\\n\\n    const getNeighbours = (flock, radius) => focal => flock.filter(\\n      boid => {\\n        const distance = getPositionOffset(focal)(boid).mag()\\n        return focal !== boid && distance < radius && distance > 0.01\\n      }\\n    )\\n\\n    const getPositionOffset = boid => target =>\\n      target.position.copy().sub(boid.position)\\n\\n    const separate = flock => boid => {\\n      const radius = boid.separation.radius\\n      const neighbours = getNeighbours(flock, radius)(boid)\\n      if (neighbours.length) {\\n        const deltas = neighbours.map(getPositionOffset(boid))\\n        const target = deltas.reduce(\\n          (acc, delta) => delta.add(acc),\\n          p.createVector(0, 0)\\n        )\\n\\n        boid.applyForce(\\n          target\\n          .copy()\\n          .div(neighbours.length)\\n          .mult(-boid.separation.force)\\n        )\\n      }\\n\\n      return boid\\n    }\\n\\n    // update loop / physics\\n    const simulate = () => {\\n      flock.forEach( separate(flock) )\\n      flock.forEach( wrap(dimensions) )\\n    }\\n    const update = () => {\\n      flock.forEach( boid => boid.update() )\\n    }\\n\\n    // draw loop / rendering\\n    p.draw = function() {\\n      // render background\\n      p.background(p.color('white'))\\n      // render flock\\n      // update world state\\n      updateSettings(flockCfg, sliders)\\n      simulate()\\n      flock.map(Art.debugBoid(p))\\n      flock.map(Art.debugMotion(p))\\n      flock.map(Art.boid(p))\\n      update()\\n    }\\n  }}\\n/>\\n```\\n\"\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/sections/flock-separation.md\n// module id = ./src/sections/flock-separation.md\n// module chunks = 22"],"mappings":";;;;;AAAA;;;;A","sourceRoot":""}