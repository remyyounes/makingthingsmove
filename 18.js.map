{"version":3,"file":"18.js","sources":["webpack:///./src/sections/collision.md"],"sourcesContent":["module.exports = \"```code\\n<P5Wrapper sketch={p => {\\n  // parameters\\n  const dimensions = { width: 600, height: 600 }\\n  const size = { width: 40, height: 40 }\\n  const dragCoefficient = 0.1\\n  const particles = []\\n  const count = 200\\n  let particle\\n\\n  p.setup = function() {\\n    // setup canvas\\n    p.createCanvas(dimensions.width, dimensions.height, p.P2D)\\n    debugger;\\n    // setup particles\\n    for (let i = 0; i < count; i++) {\\n      const particle = new Particle({\\n        position: p.createVector(  \\n          (Math.random() * dimensions.width),\\n          (Math.random() * dimensions.height)\\n        ),\\n        velocity: p.createVector(  \\n          Math.random() * 2,\\n          Math.random() * 2\\n        ),\\n        size,\\n      })\\n      particles.push(particle)\\n    }\\n  }\\n\\n\\n\\n  const checkBounds = (bounds, particle) => {\\n    const collision = { x: 0, y: 0 }\\n    const xMin = particle.position.x - particle.size.width / 2\\n    const xMax = particle.position.x + particle.size.width / 2\\n    const yMin = particle.position.y - particle.size.height / 2\\n    const yMax = particle.position.y + particle.size.height / 2\\n\\n    if (xMin <= 0 || xMax >= bounds.width) {\\n      collision.x = 1\\n    }\\n    if (yMin <= 0 || yMax >= bounds.height) {\\n      collision.y = 1\\n    }\\n    return collision\\n  }\\n\\n  const resolveOverlap = (ballA, ballB) => {\\n    const delta = ballB.position.copy().sub(ballA.position)\\n    const distance = delta.mag()\\n    var theta = Math.atan2(delta.y, delta.x);\\n    var overlap = ballA.size.width / 4 + ballB.size.width / 4 - distance;\\n    ballB.position.x += overlap * Math.cos(theta);\\n    ballB.position.y += overlap * Math.sin(theta);\\n  }\\n\\n  // update loop / physics\\n  const update = () => {\\n    for (let i = 0; i < count; i++) {\\n      for (let j = 0; j < count; j++) {\\n        if ( i !== j ) {\\n          const ballA = particles[i]\\n          const ballB = particles[j]\\n          const delta = ballB.position.copy().sub(ballA.position)\\n          if ( delta.mag() < size.width/2 ) {\\n            console.log('collision')\\n            resolveOverlap(ballA, ballB)\\n            checkCollision(ballA, ballB)\\n          }\\n        }\\n      }\\n    }\\n    particles.map(updateParticle)\\n  }\\n\\n  const updateParticle = (particle) => {\\n\\n    // check collision\\n    const collision = checkBounds(dimensions, particle)\\n\\n    // adjust velocity according to collision\\n    if (collision.x) particle.velocity.x *= -1\\n    if (collision.y) particle.velocity.y *= -1\\n\\n\\n    // update particle position and velocity then reset acceleration\\n    particle.update()\\n  }\\n\\n  const checkCollision = (ballA, ballB) => {\\n    const delta = ballB.position.copy().sub(ballA.position)\\n    const thetaA = Math.atan2(ballA.velocity.y, ballA.velocity.x);\\n    const thetaB = Math.atan2(ballB.velocity.y, ballB.velocity.x);\\n    const phi = Math.atan2(ballB.position.y, ballB.position.x);\\n\\n    const m1 = ballA.mass;\\n    const m2 = ballB.mass;\\n    const v1 = ballA.velocity.mag();\\n    const v2 = ballB.velocity.mag();\\n\\n    const dA = thetaA - phi\\n    const dB = thetaB - phi\\n\\n    ballA.velocity.x =\\n      (v1 * Math.cos(dA) * (m1-m2) + 2*m2*v2* Math.cos(dB)) /\\n      (m1 + m2) * Math.cos(phi) + v1 * Math.sin(dA) * Math.cos(phi + Math.PI/2);\\n    ballA.velocity.y =\\n      (v1 * Math.cos(dA) * (m1-m2) + 2*m2*v2* Math.cos(dB)) /\\n      (m1 + m2) * Math.sin(phi) + v1 * Math.sin(dA) * Math.sin(phi + Math.PI/2);\\n    ballB.velocity.x =\\n      (v2 *  Math.cos(dB) * (m2-m1) + 2*m1*v1*Math.cos(dA)) /\\n      (m1 + m2) * Math.cos(phi) + v2 * Math.sin(dB) * Math.cos(phi + Math.PI/2);\\n    ballB.velocity.y=\\n      (v2 *  Math.cos(dB) * (m2-m1) + 2*m1*v1*Math.cos(dA)) /\\n      (m1 + m2) * Math.sin(phi) + v2 * Math.sin(dB) * Math.sin(phi + Math.PI/2);\\n\\n}\\n\\n\\n  // draw loop / rendering\\n  p.draw = function() {\\n    // render background\\n    p.background(p.color('white'))\\n\\n    // render particle\\n    p.push()\\n    particles.map( particle => Art.ellipse(p, particle))\\n    p.pop()\\n    update()\\n  }\\n}} />\\n\\n```\\n\"\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/sections/collision.md\n// module id = ./src/sections/collision.md\n// module chunks = 18"],"mappings":";;;;;AAAA;;;;A","sourceRoot":""}